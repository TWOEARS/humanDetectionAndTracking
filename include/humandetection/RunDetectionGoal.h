// Generated by gencpp from file humandetection/RunDetectionGoal.msg
// DO NOT EDIT!


#ifndef HUMANDETECTION_MESSAGE_RUNDETECTIONGOAL_H
#define HUMANDETECTION_MESSAGE_RUNDETECTIONGOAL_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace humandetection
{
template <class ContainerAllocator>
struct RunDetectionGoal_
{
  typedef RunDetectionGoal_<ContainerAllocator> Type;

  RunDetectionGoal_()
    : frameRate(0)
    , temporalSlidingWindowSize(0)
    , detectorFrameRatio(0.0)
    , maxTrackNumber(0)
    , maxTemplateSize(0)
    , expertThreshold(0)
    , detectionRescalingFactor(0.0)
    , alphaDistribution(0.0)
    , histogramUpdateRate(0.0)
    , numberOfParticles(0)
    , framesBeforeTrackDeath(0)
    , frameHistory(0)
    , classifiers()
    , templateMatchingThreshold(0.0)
    , disparityThreshold(0.0)  {
    }
  RunDetectionGoal_(const ContainerAllocator& _alloc)
    : frameRate(0)
    , temporalSlidingWindowSize(0)
    , detectorFrameRatio(0.0)
    , maxTrackNumber(0)
    , maxTemplateSize(0)
    , expertThreshold(0)
    , detectionRescalingFactor(0.0)
    , alphaDistribution(0.0)
    , histogramUpdateRate(0.0)
    , numberOfParticles(0)
    , framesBeforeTrackDeath(0)
    , frameHistory(0)
    , classifiers(_alloc)
    , templateMatchingThreshold(0.0)
    , disparityThreshold(0.0)  {
  (void)_alloc;
    }



   typedef uint16_t _frameRate_type;
  _frameRate_type frameRate;

   typedef uint16_t _temporalSlidingWindowSize_type;
  _temporalSlidingWindowSize_type temporalSlidingWindowSize;

   typedef float _detectorFrameRatio_type;
  _detectorFrameRatio_type detectorFrameRatio;

   typedef uint16_t _maxTrackNumber_type;
  _maxTrackNumber_type maxTrackNumber;

   typedef uint16_t _maxTemplateSize_type;
  _maxTemplateSize_type maxTemplateSize;

   typedef uint16_t _expertThreshold_type;
  _expertThreshold_type expertThreshold;

   typedef float _detectionRescalingFactor_type;
  _detectionRescalingFactor_type detectionRescalingFactor;

   typedef float _alphaDistribution_type;
  _alphaDistribution_type alphaDistribution;

   typedef float _histogramUpdateRate_type;
  _histogramUpdateRate_type histogramUpdateRate;

   typedef uint16_t _numberOfParticles_type;
  _numberOfParticles_type numberOfParticles;

   typedef uint16_t _framesBeforeTrackDeath_type;
  _framesBeforeTrackDeath_type framesBeforeTrackDeath;

   typedef uint32_t _frameHistory_type;
  _frameHistory_type frameHistory;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _classifiers_type;
  _classifiers_type classifiers;

   typedef float _templateMatchingThreshold_type;
  _templateMatchingThreshold_type templateMatchingThreshold;

   typedef float _disparityThreshold_type;
  _disparityThreshold_type disparityThreshold;




  typedef boost::shared_ptr< ::humandetection::RunDetectionGoal_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::humandetection::RunDetectionGoal_<ContainerAllocator> const> ConstPtr;

}; // struct RunDetectionGoal_

typedef ::humandetection::RunDetectionGoal_<std::allocator<void> > RunDetectionGoal;

typedef boost::shared_ptr< ::humandetection::RunDetectionGoal > RunDetectionGoalPtr;
typedef boost::shared_ptr< ::humandetection::RunDetectionGoal const> RunDetectionGoalConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::humandetection::RunDetectionGoal_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::humandetection::RunDetectionGoal_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace humandetection

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'sensor_msgs': ['/opt/ros/indigo/share/sensor_msgs/msg', '/opt/ros/indigo/share/sensor_msgs/msg'], 'actionlib_msgs': ['/opt/ros/indigo/share/actionlib_msgs/msg'], 'std_msgs': ['/opt/ros/indigo/share/std_msgs/msg'], 'humandetection': ['humandetection/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::humandetection::RunDetectionGoal_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::humandetection::RunDetectionGoal_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::humandetection::RunDetectionGoal_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
{
  static const char* value()
  {
    return "87faf4ffe0556508a3e10352e3144b54";
  }

  static const char* value(const ::humandetection::RunDetectionGoal_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x87faf4ffe0556508ULL;
  static const uint64_t static_value2 = 0xa3e10352e3144b54ULL;
};

template<class ContainerAllocator>
struct DataType< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
{
  static const char* value()
  {
    return "humandetection/RunDetectionGoal";
  }

  static const char* value(const ::humandetection::RunDetectionGoal_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n\
# service RunDetection\n\
uint16 frameRate\n\
uint16 temporalSlidingWindowSize\n\
float32 detectorFrameRatio\n\
uint16 maxTrackNumber\n\
uint16 maxTemplateSize\n\
uint16 expertThreshold\n\
float32 detectionRescalingFactor\n\
float32 alphaDistribution\n\
float32 histogramUpdateRate\n\
uint16 numberOfParticles\n\
uint16 framesBeforeTrackDeath\n\
uint32 frameHistory\n\
string classifiers\n\
float32 templateMatchingThreshold\n\
float32 disparityThreshold\n\
";
  }

  static const char* value(const ::humandetection::RunDetectionGoal_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.frameRate);
      stream.next(m.temporalSlidingWindowSize);
      stream.next(m.detectorFrameRatio);
      stream.next(m.maxTrackNumber);
      stream.next(m.maxTemplateSize);
      stream.next(m.expertThreshold);
      stream.next(m.detectionRescalingFactor);
      stream.next(m.alphaDistribution);
      stream.next(m.histogramUpdateRate);
      stream.next(m.numberOfParticles);
      stream.next(m.framesBeforeTrackDeath);
      stream.next(m.frameHistory);
      stream.next(m.classifiers);
      stream.next(m.templateMatchingThreshold);
      stream.next(m.disparityThreshold);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct RunDetectionGoal_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::humandetection::RunDetectionGoal_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::humandetection::RunDetectionGoal_<ContainerAllocator>& v)
  {
    s << indent << "frameRate: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.frameRate);
    s << indent << "temporalSlidingWindowSize: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.temporalSlidingWindowSize);
    s << indent << "detectorFrameRatio: ";
    Printer<float>::stream(s, indent + "  ", v.detectorFrameRatio);
    s << indent << "maxTrackNumber: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.maxTrackNumber);
    s << indent << "maxTemplateSize: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.maxTemplateSize);
    s << indent << "expertThreshold: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.expertThreshold);
    s << indent << "detectionRescalingFactor: ";
    Printer<float>::stream(s, indent + "  ", v.detectionRescalingFactor);
    s << indent << "alphaDistribution: ";
    Printer<float>::stream(s, indent + "  ", v.alphaDistribution);
    s << indent << "histogramUpdateRate: ";
    Printer<float>::stream(s, indent + "  ", v.histogramUpdateRate);
    s << indent << "numberOfParticles: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.numberOfParticles);
    s << indent << "framesBeforeTrackDeath: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.framesBeforeTrackDeath);
    s << indent << "frameHistory: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.frameHistory);
    s << indent << "classifiers: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.classifiers);
    s << indent << "templateMatchingThreshold: ";
    Printer<float>::stream(s, indent + "  ", v.templateMatchingThreshold);
    s << indent << "disparityThreshold: ";
    Printer<float>::stream(s, indent + "  ", v.disparityThreshold);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HUMANDETECTION_MESSAGE_RUNDETECTIONGOAL_H
